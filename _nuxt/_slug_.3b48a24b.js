import{i as A,r as y,j as B,k as R,l as O,m as $,u as h,p as j,a as H,q as I,s as S,b as p,e as z,t as E,o as m}from"./entry.db24677e.js";const T=()=>null;function N(...o){var g,D,x,b,w,C,P,k;const i=typeof o[o.length-1]=="string"?o.pop():void 0;typeof o[0]!="string"&&o.unshift(i);let[t,c,e={}]=o;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=(g=e.server)!=null?g:!0,e.default=(D=e.default)!=null?D:T,e.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),e.lazy=(b=(x=e.lazy)!=null?x:e.defer)!=null?b:!1,e.initialCache=(w=e.initialCache)!=null?w:!0,e.immediate=(C=e.immediate)!=null?C:!0;const a=A(),d=()=>(a.isHydrating||e.initialCache)&&a.payload.data[t]!==void 0;a._asyncData[t]||(a._asyncData[t]={data:y(d()?a.payload.data[t]:(k=(P=e.default)==null?void 0:P.call(e))!=null?k:null),pending:y(!d()),error:y(a.payload._errors[t]?B(a.payload._errors[t]):null)});const n={...a._asyncData[t]};n.refresh=n.execute=(s={})=>{if(a._asyncDataPromises[t]){if(s.dedupe===!1)return a._asyncDataPromises[t];a._asyncDataPromises[t].cancelled=!0}if(s._initial&&d())return a.payload.data[t];n.pending.value=!0;const l=new Promise((r,u)=>{try{r(c(a))}catch(f){u(f)}}).then(r=>{if(l.cancelled)return a._asyncDataPromises[t];e.transform&&(r=e.transform(r)),e.pick&&(r=q(r,e.pick)),n.data.value=r,n.error.value=null}).catch(r=>{var u,f;if(l.cancelled)return a._asyncDataPromises[t];n.error.value=r,n.data.value=h((f=(u=e.default)==null?void 0:u.call(e))!=null?f:null)}).finally(()=>{l.cancelled||(n.pending.value=!1,a.payload.data[t]=n.data.value,n.error.value&&(a.payload._errors[t]=B(n.error.value)),delete a._asyncDataPromises[t])});return a._asyncDataPromises[t]=l,a._asyncDataPromises[t]};const _=()=>n.refresh({_initial:!0}),M=e.server!==!1&&a.payload.serverRendered;{const s=j();if(s&&!s._nuxtOnBeforeMountCbs){s._nuxtOnBeforeMountCbs=[];const r=s._nuxtOnBeforeMountCbs;s&&(R(()=>{r.forEach(u=>{u()}),r.splice(0,r.length)}),O(()=>r.splice(0,r.length)))}M&&a.isHydrating&&t in a.payload.data?n.pending.value=!1:s&&(a.payload.serverRendered&&a.isHydrating||e.lazy)&&e.immediate?s._nuxtOnBeforeMountCbs.push(_):e.immediate&&_(),e.watch&&$(e.watch,()=>n.refresh());const l=a.hook("app:data:refresh",r=>{if(!r||r.includes(t))return n.refresh()});s&&O(l)}const v=Promise.resolve(a._asyncDataPromises[t]).then(()=>n);return Object.assign(v,n),v}function q(o,i){const t={};for(const c of i)t[c]=o[c];return t}const F={class:"container mx-auto min-h-screen bg-slate-50 px-10 text-center"},K={class:"font-bold text-6xl my-8 capitalize text-gray-600"},L={key:0},U={key:1},X=H({__name:"[slug]",async setup(o){let i,t;const c=I();console.log(c.params.slug);const{data:e,pending:a}=([i,t]=S(()=>N(()=>$fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${c.params.slug}`),"$nhmnI82TfX")),i=await i,t(),i);return console.log(e,a),(d,n)=>(m(),p("div",F,[z("h2",K,E(d.$route.params.slug),1),h(a)?(m(),p("div",U," Loading... ")):(m(),p("div",L,[z("pre",null,E(h(e)),1)]))]))}});export{X as default};
